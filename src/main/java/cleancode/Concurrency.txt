"Objects are abstractions of processing. Threads are abstractions of schedule."

Decoupling strategy. Decouple what gets done from when it gets done.  - Separate concerns

Just-in-Time compiler does with the generated byte-code, java memory model for atomic

public class X {
      private int lastIdUsed;

      public int getNextId() {
           return ++lastIdUsed;
       }
   }
Create the instance of class X, and share between two threads, there are 12870 different possible execution paths for two threads

1. Concurrency defense principles
1.1. SRP( Single Responsibility Principle ) - Keep your concurrency-related code separate from other code
1.2. Corollary: Limit the scope of data - Take data encapsulation to heart; severely limit the access of any data that may be shared
1.3. Corollary: Use copies of data - Threads should be as independent as possible - Attempt to partition data into independent subsets than can be operated by independent threads, possibly in different processors.
1.4. Become familiar with java.util.concurrent, java.util.concurrent.atomic, java.util.concurrent.locks
1.5. Different ways for partition behavior - Execution model
    1.5.1 Bound Resources - Producer-Consumer Model
    1.5.2 Mutual Exclusion -
    1.5.3 Starvation - Readers-Writers Model
    1.5.4 Deadlock
    1.5.5 Livelock

Appendix: Some background knowledge:
1. JVM: interpret the bytecode
   1.1 Java code -> bytecode -> native machine code
   1.2 Java code -> bytecode -> directly executed on a processor whose Instruction Set Architecture is the bytecode specification
2. A servlet: a class which responds to a particular type of network request. Servlets run in servlet container which handles the networking side( parsing HTTP request, connection handling etc )
